'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = require("web3");
const ethereumjs_tx_1 = require("ethereumjs-tx");
class BlockchainService {
    constructor(RPC, gasPrice, ABI, SCA) {
        this.WEB3 = new web3_1.default(new web3_1.default.providers.HttpProvider(RPC));
        this.gasPrice = gasPrice;
        this.ABI = ABI;
        this.SCA = SCA;
    }
    async createRaw(funcName = "", params = [], from = "") {
        let ABI = JSON.parse(this.ABI.toString());
        const contractDeployed = new this.WEB3.eth.Contract(ABI, this.SCA);
        const dataFunc = await contractDeployed.methods[funcName](...params).encodeABI();
        const gasLimit = await contractDeployed.methods[funcName](...params).estimateGas();
        const nonce = await this.WEB3.eth.getTransactionCount(from);
        const rawTx = {
            from: from,
            to: this.SCA,
            gasLimit,
            gasPrice: this.gasPrice,
            nonce: nonce,
            data: dataFunc,
        };
        console.log("raw", rawTx);
        return rawTx;
    }
    async sendRaw(rawTx = {}, privateKey, chainId = 97) {
        privateKey = Buffer.from(privateKey, 'hex');
        var transaction = new ethereumjs_tx_1.Transaction(rawTx, { chain: chainId });
        await transaction.sign(privateKey);
        let signedTx = '0x' + transaction.serialize().toString('hex');
        let txHash = this.WEB3.utils.keccak256(signedTx);
        const tx = await this.WEB3.eth.sendSignedTransaction(signedTx);
        return { txHash, tx };
    }
    async readFunc(funcName = "", params = [], from) {
        let ABI = JSON.parse(this.ABI.toString());
        const contractDeployed = new this.WEB3.eth.Contract(ABI, this.SCA);
        const dataFunc = await contractDeployed.methods[funcName](...params).call({ from });
        return dataFunc;
    }
    async getReceipt() {
    }
    async getEvent() {
    }
}
exports.default = BlockchainService;
//# sourceMappingURL=index.js.map